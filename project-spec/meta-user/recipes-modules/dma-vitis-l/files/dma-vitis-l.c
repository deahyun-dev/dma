/*  dma-l.c - The simplest kernel module.

* Copyright (C) 2013 - 2016 Xilinx, Inc
*
*   This program is free software; you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation; either version 2 of the License, or
*   (at your option) any later version.

*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License along
*   with this program. If not, see <http://www.gnu.org/licenses/>.

*/

#define DMA_H

#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <linux/interrupt.h>

#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>

#include <linux/dma-mapping.h>
#include <asm/page.h>
// #include <kernel/dma/direct.h>

/********************************************************************************************************/

//header files
#include <linux/uaccess.h> // copy_from_user
#include <linux/miscdevice.h> // for user interface with fops
#include <linux/fs.h> // for file_operation
#include <asm/io.h> //iowrite, ioread
#include "my_emul.h"
#include "xaxidma_bd.h"

#include "xaxidma.h"
#include "functions.h"

/********************************************************************************************************/

/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR
    ("Xilinx Inc.");
MODULE_DESCRIPTION
    ("dma-l - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "dma-l"
#define DEVICE_NAME "dma" //* put device name(IP name)
/********************************************************************************************************/

void __iomem* base_addr; //virtual address
UINTPTR dma_addr;

UINTPTR TX_BD_virt_addr;
UINTPTR RX_BD_virt_addr;
UINTPTR TX_BUF_virt_addr;
UINTPTR RX_BUF_virt_addr;

dma_addr_t TX_BD_phy_addr;
dma_addr_t RX_BD_phy_addr;
dma_addr_t TX_BUF_phy_addr;
dma_addr_t RX_BUF_phy_addr;

struct device *dma_dev;

XAxiDma AxiDma;
/******************** Constant Definitions **********************************/

/*
 * Device hardware build related constants.
 */

// #define DMA_DEV_ID		XPAR_AXIDMA_0_DEVICE_ID

/************************** Variable Definitions *****************************/

/*
 * Buffer for transmit packet. Must be 32-bit aligned to be used by DMA.
 */
// u32 *Packet = (u32 *) TX_BUFFER_BASE;

// emulation

//file operation

#define BUF_SIZE 100
ssize_t cur_len;     // 현재 버퍼에 저장된 데이터 크기

int dma_l_open(struct inode *inode, struct file *filp){
    // printk(KERN_ALERT "dma_l_device open function called\n");
    return 0;
}

int dma_l_release(struct inode *inode, struct file *filp){
    // printk(KERN_ALERT "dma_l_device release function called\n");
    return 0;
}

ssize_t dma_l_write(struct file *filp, const char *buf, size_t count, loff_t *f_pos) {
    printk(KERN_ALERT "dma_l_device write function called\n");
    ssize_t retval;
 
    if(count > BUF_SIZE){ //buffer size check. BUF_SIZE 100
        retval = -ENOMEM;
        goto out;
    }
 
    cur_len = retval = count;

    char kernel_buffer[BUF_SIZE];
    printk("check1\n");
    // 사용자가 전달한 데이터를 버퍼에 저장.
    if(copy_from_user(kernel_buffer, buf, retval)){ // buf : userspace에서 넘긴 val_str, kernel_buffer : kernel space buffer
        retval = -EFAULT;
        goto out;
    }
    printk("check2\n");
    

    printk("receive data from user : %s", kernel_buffer);

    unsigned long value = simple_strtoul(kernel_buffer, NULL, 10); // str to unsined long conversion
    

    //dma_l_set_register(base_addr, 0, value); // device control by driver function
 
    printk("drv_buffer_write: [%dbyte -> %dbyte]\n", count, retval);
 
out:
    return retval;

}

ssize_t dma_l_read(struct file *filp, char *buf, size_t count, loff_t *f_pos) {
    printk("dma_l_device read function called\n");    
    return count;
}

long dma_l_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg){

	int ret;
	int Status;
    
    XAxiDma_Config *Config;

    switch(cmd){
		case DMA_In32:

            Config = XAxiDma_LookupConfig(DMA_DEV_ID);
	        if (!Config) {
		        printk("No config found for %d\r\n", DMA_DEV_ID);
		        return XST_FAILURE;
	        }
            // printk("check 0\n");

            Config->BaseAddr = base_addr;
            printk("Config->BaseAddr %08x\n", Config->BaseAddr);

	        /* Initialize DMA engine */
	        Status = XAxiDma_CfgInitialize(&AxiDma, Config);
	        if (Status != XST_SUCCESS) {
	        	printk("Initialization failed %d\r\n", Status);
	        	return XST_FAILURE;
	        }

            // printk("check 1\n");

	        if(!XAxiDma_HasSg(&AxiDma)) {
	        	printk("Device configured as Simple mode \r\n");
	        	return XST_FAILURE;
	        }

			printk("/****************** Tx Start **************************/\n");

            Status = TxSetup(&AxiDma);
	        if (Status != XST_SUCCESS) {
	        	return XST_FAILURE;
	        }
			XAxiDma_BdRing *TxRingPtr = XAxiDma_GetTxRing(&AxiDma);
            printk("TxSetup finish\n");
		 	u32 tmp = XAxiDma_ReadReg(TxRingPtr->ChanBase, XAXIDMA_SR_OFFSET);
			printk("XAXIDMA_SR_OFFSET %08x\n", tmp);

			printk("/****************** Rx Start **************************/\n");

            Status = RxSetup(&AxiDma);
	        if (Status != XST_SUCCESS) {
	        	return XST_FAILURE;
	        }

            /* Send a packet */
	        Status = SendPacket(&AxiDma);
	        if (Status != XST_SUCCESS) {
	        	return XST_FAILURE;
	        }
			// udelay(10000);

	        /* Check DMA transfer result */
	        Status = CheckDmaResult(&AxiDma);

	        if (Status != XST_SUCCESS) {
	        	printk("AXI DMA SG Polling Example Failed\r\n");
	        	return XST_FAILURE;
	        }

	        printk("Successfully ran AXI DMA SG Polling Example\r\n");
	        printk("--- Exiting main() --- \r\n");
    
            break;	
        case DMA_Out32:

			TX_BD_virt_addr = dma_alloc_coherent(dma_dev, DMA_BUF_SIZE * 16, &TX_BD_phy_addr, GFP_ATOMIC);
        	printk("TX_BD_virt_addr %08x", TX_BD_virt_addr);
        	printk("TX_BD_phy_addr %08x", TX_BD_phy_addr);    

			RX_BD_virt_addr = (u32)TX_BD_virt_addr + DMA_BUF_SIZE;
			RX_BD_phy_addr = (u32)TX_BD_phy_addr + DMA_BUF_SIZE;
        	// RX_BD_virt_addr = dma_alloc_coherent(dev, DMA_BUF_SIZE, &RX_BD_phy_addr, GFP_ATOMIC);
        	printk("RX_BD_virt_addr %08x", RX_BD_virt_addr);
        	printk("RX_BD_phy_addr %08x", RX_BD_phy_addr);

			TX_BUF_virt_addr = (u32)RX_BD_virt_addr + DMA_BUF_SIZE;
			TX_BUF_phy_addr = (u32)RX_BD_phy_addr + DMA_BUF_SIZE;
        	// TX_BUF_virt_addr = dma_alloc_coherent(dev, DMA_BUF_SIZE * 8, &TX_BUF_phy_addr, GFP_ATOMIC);
        	printk("TX_BUF_virt_addr %08x", TX_BUF_virt_addr);
        	printk("TX_BUF_phy_addr %08x", TX_BUF_phy_addr);

			RX_BUF_virt_addr = (u32)TX_BUF_virt_addr + DMA_BUF_SIZE * 7;
			RX_BUF_phy_addr = (u32)TX_BUF_phy_addr + DMA_BUF_SIZE * 7;
        	// RX_BUF_virt_addr = dma_alloc_coherent(dev, DMA_BUF_SIZE * 8, &RX_BUF_phy_addr, GFP_ATOMIC);
        	printk("RX_BUF_virt_addr %08x", RX_BUF_virt_addr);
        	printk("RX_BUF_phy_addr %08x", RX_BUF_phy_addr);    


            printk("check 3\n");


            break;
        default:
            printk("DMA default\n");
            break;
    }
    return 0;
}

static struct file_operations dma_l_fops ={ // system call
    .open = dma_l_open,
    .release = dma_l_release,
    .read = dma_l_read,   //dummy
    .write = dma_l_write, //for test
    .unlocked_ioctl = dma_l_unlocked_ioctl, //ioctl로 모든 driver function mapping
};

// misc device structure
 static struct miscdevice dma_l_miscdev = {
    .minor      = MISC_DYNAMIC_MINOR,   //부번호 동적할당
    .name       = DEVICE_NAME,    // device file name -> /dev/dma_l
    .fops       = &dma_l_fops, // system call for user space
};

/********************************************************************************************************/
unsigned myint = 0xdeadbeef;
char *mystr = "default";

module_param(myint, int, S_IRUGO);
module_param(mystr, charp, S_IRUGO);

struct dma_l_local {
    int irq;
    unsigned long mem_start;
    unsigned long mem_end;
    void __iomem *base_addr;
};

static irqreturn_t dma_l_irq(int irq, void *lp)
{
    printk("dma-l interrupt\n");
    return IRQ_HANDLED;
}

static int dma_l_probe(struct platform_device *pdev)
{
    struct resource *r_irq; /* Interrupt resources */
    struct resource *r_mem; /* IO mem resources */
    struct device *dev = &pdev->dev;
	dma_dev = &pdev->dev;
    struct dma_l_local *lp = NULL;

    int rc = 0;
    dev_info(dev, "Device Tree Probing\n");
    /* Get iospace for the device */
    r_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    if (!r_mem) {
        dev_err(dev, "invalid address\n");
        return -ENODEV;
    }
    lp = (struct dma_l_local *) kmalloc(sizeof(struct dma_l_local), GFP_KERNEL);
    if (!lp) {
        dev_err(dev, "Cound not allocate dma-l device\n");
        return -ENOMEM;
    }
    dev_set_drvdata(dev, lp);
    lp->mem_start = r_mem->start;
    lp->mem_end = r_mem->end;

    if (!request_mem_region(lp->mem_start,
                lp->mem_end - lp->mem_start + 1,
                DRIVER_NAME)) {
        dev_err(dev, "Couldn't lock memory region at %p\n",
            (void *)lp->mem_start);
        rc = -EBUSY;
        goto error1;
    }

    lp->base_addr = ioremap(lp->mem_start, (lp->mem_end - lp->mem_start + 1)); // lp->base_addr : virtual address
    base_addr = lp->base_addr;

    if (!lp->base_addr) {
        dev_err(dev, "dma-l: Could not allocate iomem\n");
        rc = -EIO;
        goto error2;
    }

    /********************************************************************************************************/

    //misc device registration for user space
    int ret = 0;
    ret = misc_register(&dma_l_miscdev); // misc device 등록. 플랫폼 디바이스 등록과는 independant. fops를 userspace에 넘겨주기 위한 key
                                          // user는 생성된 /dev/dma_l file을 열고 file_operation을 통해 driver 함수 사용 가능
    if (ret){
        printk("misc_register() failed");
        return -1;
    }

    /********************************************************************************************************/


    /* Get IRQ for the device */
    r_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
    if (!r_irq) {
        dev_info(dev, "no IRQ found\n");
        dev_info(dev, "dma-l at 0x%08x mapped to 0x%08x\n",
            (unsigned int __force)lp->mem_start,
            (unsigned int __force)lp->base_addr);
        return 0;
    }
    lp->irq = r_irq->start;
    rc = request_irq(lp->irq, &dma_l_irq, 0, DRIVER_NAME, lp);
    if (rc) {
        dev_err(dev, "testmodule: Could not allocate interrupt %d.\n",
            lp->irq);
        goto error3;
    }

    dev_info(dev,"dma-l at 0x%08x mapped to 0x%08x, irq=%d\n",
        (unsigned int __force)lp->mem_start,
        (unsigned int __force)lp->base_addr,
        lp->irq);


    return 0;
error3:
    free_irq(lp->irq, lp);
error2:
    release_mem_region(lp->mem_start, lp->mem_end - lp->mem_start + 1);
error1:
    kfree(lp);
    dev_set_drvdata(dev, NULL);
    return rc;
}

static int dma_l_remove(struct platform_device *pdev)
{
    struct device *dev = &pdev->dev;
    struct dma_l_local *lp = dev_get_drvdata(dev);
    free_irq(lp->irq, lp);
    iounmap(lp->base_addr);
    release_mem_region(lp->mem_start, (lp->mem_end - lp->mem_start + 1));

    kfree(lp);
    dev_set_drvdata(dev, NULL);
    return 0;
}

/**********************************************************************/

//platform deivce & driver setting

static const struct platform_device_id dma_l_id_table[] = {
    {DEVICE_NAME}
};

#ifdef CONFIG_OF
static struct of_device_id dma_l_of_match[] = {
    { .compatible = "xlnx,axi-dma-7.1", "xlnx,axi-dma-1.00.a", }, //*compatible name in device tree(pl.dtsi)
    { /* end of list */ },
};
MODULE_DEVICE_TABLE(of, dma_l_of_match);
#else
# define dma_l_of_match
#endif

static struct platform_driver dma_l_driver = {
    .driver = {
        .name = DEVICE_NAME, // driver name = device name
        .owner = THIS_MODULE,
        .of_match_table = dma_l_of_match,
    },
    .probe      = dma_l_probe,
    .remove     = dma_l_remove,
    .id_table   = dma_l_id_table, // for device hot plug
};

/**********************************************************************/

static int __init dma_l_init(void)
{
    printk("<1>Hello module world.\n");
    printk("<1>Module parameters were (0x%08x) and \"%s\"\n", myint,
           mystr);

    return platform_driver_register(&dma_l_driver);
}

static void __exit dma_l_exit(void)
{
    platform_driver_unregister(&dma_l_driver);
    printk(KERN_ALERT "Goodbye module world.\n");
}

module_init(dma_l_init);
module_exit(dma_l_exit);


int RxSetup(XAxiDma * AxiDmaInstPtr)
{
	XAxiDma_BdRing *RxRingPtr;
	int Delay = 0;
	int Coalesce = 1;
	int Status;
	XAxiDma_Bd BdTemplate;
	XAxiDma_Bd *BdPtr;
	XAxiDma_Bd *BdCurPtr;
	u32 BdCount;
	u32 FreeBdCount;
	UINTPTR RxBufferPtr;
	int Index;
	u32 tmp;


	RxRingPtr = XAxiDma_GetRxRing(&AxiDma);

	/* Disable all RX interrupts before RxBD space setup */

	// XAxiDma_BdRingIntDisable(RxRingPtr, XAXIDMA_IRQ_ALL_MASK);

	/* Set delay and coalescing */
	XAxiDma_BdRingSetCoalesce(RxRingPtr, Coalesce, Delay);

	/* Setup Rx BD space */
	// BdCount = XAxiDma_BdRingCntCalc(XAXIDMA_BD_MINIMUM_ALIGNMENT,
	// 			RX_BD_SPACE_HIGH - RX_BD_SPACE_BASE + 1);

	BdCount = XAxiDma_BdRingCntCalc(XAXIDMA_BD_MINIMUM_ALIGNMENT,
				DMA_BUF_SIZE);

	Status = XAxiDma_BdRingCreate(RxRingPtr, RX_BD_phy_addr,
				RX_BD_virt_addr,
				XAXIDMA_BD_MINIMUM_ALIGNMENT, BdCount);

	if (Status != XST_SUCCESS) {
		printk("RX create BD ring failed %d\r\n", Status);

		return XST_FAILURE;
	}

	/*
	 * Setup an all-zero BD as the template for the Rx channel.
	 */
	// XAxiDma_BdClear(&BdTemplate);
    memset((void *)((u32)&BdTemplate + XAXIDMA_BD_START_CLEAR), 0, XAXIDMA_BD_BYTES_TO_CLEAR);

	Status = XAxiDma_BdRingClone(RxRingPtr, &BdTemplate);
	if (Status != XST_SUCCESS) {
		printk("RX clone BD failed %d\r\n", Status);

		return XST_FAILURE;
	}

	/* Attach buffers to RxBD ring so we are ready to receive packets */
    // printk("RX check 0\r\n");
	FreeBdCount = XAxiDma_BdRingGetFreeCnt(RxRingPtr);
    printk("Rx FreeBdCount %08x\n", FreeBdCount);
	Status = XAxiDma_BdRingAlloc(RxRingPtr, FreeBdCount, &BdPtr);
	if (Status != XST_SUCCESS) {
		printk("RX alloc BD failed %d\r\n", Status);

		return XST_FAILURE;
	}
    // printk("RX check 2\r\n");
	BdCurPtr = BdPtr;
    // printk("BdCurPtr %08x\r\n", BdCurPtr);
	// RxBufferPtr = RX_BUFFER_BASE;
    // RxBufferPtr = RX_BUF_virt_addr;
	RxBufferPtr = RX_BUF_phy_addr;
    printk("physical RxBufferPtr %08x\r\n", RxBufferPtr);
	for (Index = 0; Index < FreeBdCount; Index++) {
		Status = XAxiDma_BdSetBufAddr(BdCurPtr, RxBufferPtr);

		if (Status != XST_SUCCESS) {
			printk("Set buffer addr %x on BD %x failed %d\r\n",
			    (unsigned int)RxBufferPtr,
			    (UINTPTR)BdCurPtr, Status);

			return XST_FAILURE;
		}

		Status = XAxiDma_BdSetLength(BdCurPtr, MAX_PKT_LEN,
				RxRingPtr->MaxTransferLen);
		if (Status != XST_SUCCESS) {
			printk("Rx set length %d on BD %x failed %d\r\n",
			    MAX_PKT_LEN, (UINTPTR)BdCurPtr, Status);

			return XST_FAILURE;
		}

		/* Receive BDs do not need to set anything for the control
		 * The hardware will set the SOF/EOF bits per stream status
		 */
		XAxiDma_BdSetCtrl(BdCurPtr, 0);
		XAxiDma_BdSetId(BdCurPtr, RxBufferPtr);
		tmp = (u32)RxBufferPtr + MAX_PKT_LEN;
		RxBufferPtr = (UINTPTR)tmp;
	
		printk("RxBufferPtr %08x\r\n", RxBufferPtr);
		BdCurPtr = (XAxiDma_Bd *)XAxiDma_BdRingNext(RxRingPtr, BdCurPtr);
		printk("BdCurPtr %08x\r\n", BdCurPtr);
	}

	/* Clear the receive buffer, so we can verify data
	 */
	memset((void *)RX_BUF_virt_addr, 0, MAX_PKT_LEN);
    
	Status = XAxiDma_BdRingToHw(RxRingPtr, FreeBdCount,
						BdPtr);
	if (Status != XST_SUCCESS) {
		printk("RX submit hw failed %d\r\n", Status);

		return XST_FAILURE;
	}
    
	/* Start RX DMA channel */
	Status = XAxiDma_BdRingStart(RxRingPtr);
	if (Status != XST_SUCCESS) {
		printk("RX start hw failed %d\r\n", Status);

		return XST_FAILURE;
	}
    printk("RX check 6\r\n");
	return XST_SUCCESS;
}

/*****************************************************************************/
/**
*
* This function sets up the TX channel of a DMA engine to be ready for packet
* transmission
*
* @param	AxiDmaInstPtr is the instance pointer to the DMA engine.
*
* @return	XST_SUCCESS if the setup is successful, XST_FAILURE otherwise.
*
* @note		None.
*
******************************************************************************/
int TxSetup(XAxiDma * AxiDmaInstPtr)
{
	XAxiDma_BdRing *TxRingPtr;
	XAxiDma_Bd BdTemplate;
	int Delay = 0;
	int Coalesce = 1;
	int Status;
	u32 BdCount;

	TxRingPtr = XAxiDma_GetTxRing(&AxiDma);

	/* Disable all TX interrupts before TxBD space setup */

	// XAxiDma_BdRingIntDisable(TxRingPtr, XAXIDMA_IRQ_ALL_MASK);

	/* Set TX delay and coalesce */
	XAxiDma_BdRingSetCoalesce(TxRingPtr, Coalesce, Delay);

	/* Setup TxBD space  */
    // BdCount = XAxiDma_BdRingCntCalc(XAXIDMA_BD_MINIMUM_ALIGNMENT,
	// 		TX_BD_SPACE_HIGH - TX_BD_SPACE_BASE + 1);

	BdCount = XAxiDma_BdRingCntCalc(XAXIDMA_BD_MINIMUM_ALIGNMENT,
				DMA_BUF_SIZE);

    // printk("Tx check 0\n");

	Status = XAxiDma_BdRingCreate(TxRingPtr, TX_BD_phy_addr,
				TX_BD_virt_addr,
				XAXIDMA_BD_MINIMUM_ALIGNMENT, BdCount);

    // printk("Tx check 1\n");            
	if (Status != XST_SUCCESS) {
		printk("failed create BD ring in txsetup\r\n");

		return XST_FAILURE;
	}

	/*
	 * We create an all-zero BD as the template.
	 */
	// XAxiDma_BdClear(&BdTemplate);
    memset((void *)((u32)&BdTemplate + XAXIDMA_BD_START_CLEAR), 0, XAXIDMA_BD_BYTES_TO_CLEAR);
        
	Status = XAxiDma_BdRingClone(TxRingPtr, &BdTemplate);
	if (Status != XST_SUCCESS) {
		printk("failed bdring clone in txsetup %d\r\n", Status);

		return XST_FAILURE;
	}
    printk("Tx check 3\n");    

	/* Start the TX channel */
	Status = XAxiDma_BdRingStart(TxRingPtr);
	if (Status != XST_SUCCESS) {
		printk("failed start bdring txsetup %d\r\n", Status);

		return XST_FAILURE;
	}
    printk("Tx check finish\n");    
	return XST_SUCCESS;
}

/*****************************************************************************/
/**
*
* This function transmits one packet non-blockingly through the DMA engine.
*
* @param	AxiDmaInstPtr points to the DMA engine instance
*
* @return	- XST_SUCCESS if the DMA accepts the packet successfully,
*		- XST_FAILURE otherwise.
*
* @note     None.
*
******************************************************************************/
int SendPacket(XAxiDma * AxiDmaInstPtr)
{
	XAxiDma_BdRing *TxRingPtr;
	u8 *TxPacket;
	u8 Value;
	XAxiDma_Bd *BdPtr;
	int Status;
	int Index;

    u32 *Packet = TX_BUF_virt_addr;

    printk("Packet %08x\n", Packet);

	TxRingPtr = XAxiDma_GetTxRing(AxiDmaInstPtr);

    printk("TxRingPtr %08x\n", TxRingPtr);
    printk("TxRingPtr->FreeHead %08x\n", TxRingPtr->FreeHead);
	/* Create pattern in the packet to transmit */
	TxPacket = (u8 *) Packet;

	Value = TEST_START_VALUE;

	for(Index = 0; Index < MAX_PKT_LEN; Index ++) {
		TxPacket[Index] = Value;
		printk("TxPacket[%d] : %08x\n", Index, TxPacket[Index]);
		Value = (Value + 1) & 0xFF;
	}

	/* Flush the buffers before the DMA transfer, in case the Data Cache
	 * is enabled
	 */
	XAXIDMA_CACHE_FLUSH((UINTPTR)TxPacket);
	XAXIDMA_CACHE_FLUSH((UINTPTR)RX_BUF_virt_addr);

	/* Allocate a BD */
	Status = XAxiDma_BdRingAlloc(TxRingPtr, 1, &BdPtr);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}
    
	/* Set up the BD using the information of the packet to transmit */
	Status = XAxiDma_BdSetBufAddr(BdPtr, TX_BUF_phy_addr); // modefied_0107 virtual to physical change
	if (Status != XST_SUCCESS) {
		printk("Tx set buffer addr %x on BD %x failed %d\r\n",
		    (UINTPTR)Packet, (UINTPTR)BdPtr, Status);

		return XST_FAILURE;
	}

	Status = XAxiDma_BdSetLength(BdPtr, MAX_PKT_LEN,
				TxRingPtr->MaxTransferLen);
	if (Status != XST_SUCCESS) {
		printk("Tx set length %d on BD %x failed %d\r\n",
		    MAX_PKT_LEN, (UINTPTR)BdPtr, Status);

		return XST_FAILURE;
	}
 
#if (XPAR_AXIDMA_0_SG_INCLUDE_STSCNTRL_STRM == 1)
	printk("send check 0\n");
	Status = XAxiDma_BdSetAppWord(BdPtr,
	    XAXIDMA_LAST_APPWORD, MAX_PKT_LEN);

	/* If Set app length failed, it is not fatal
	 */
	if (Status != XST_SUCCESS) {
		printk("Set app word failed with %d\r\n", Status);
	}
#endif
    
	/* For single packet, both SOF and EOF are to be set
	 */
	XAxiDma_BdSetCtrl(BdPtr, XAXIDMA_BD_CTRL_TXEOF_MASK | XAXIDMA_BD_CTRL_TXSOF_MASK);

	XAxiDma_BdSetId(BdPtr, (UINTPTR)Packet);
	printk("/********************SendPacket***************************/\n");
	/* Give the BD to DMA to kick off the transmission. */
	Status = XAxiDma_BdRingToHw(TxRingPtr, 1, BdPtr);
	if (Status != XST_SUCCESS) {
		printk("to hw failed %d\r\n", Status);
		return XST_FAILURE;
	}

	return XST_SUCCESS;
}

/*****************************************************************************/
/*
*
* This function checks data buffer after the DMA transfer is finished.
*
* @param	None
*
* @return	- XST_SUCCESS if validation is successful
*		- XST_FAILURE if validation is failure.
*
* @note		None.
*
******************************************************************************/
int CheckData(void)
{
	u8 *RxPacket;
	int Index = 0;
	u8 Value;

	RxPacket = (u8 *) RX_BUF_virt_addr;
	Value = TEST_START_VALUE;

	/* Invalidate the DestBuffer before receiving the data, in case the
	 * Data Cache is enabled
	 */
	XAXIDMA_CACHE_INVALIDATE((UINTPTR)RxPacket);



	for(Index = 0; Index < MAX_PKT_LEN; Index++) {
		if (RxPacket[Index] != Value) {
			printk("Data error %d: %x/%x\r\n",
			    Index, (unsigned int)RxPacket[Index],
			    (unsigned int)Value);

			return XST_FAILURE;
		}
		Value = (Value + 1) & 0xFF;
	}
	
	return XST_SUCCESS;
}

/*****************************************************************************/
/**
*
* This function waits until the DMA transaction is finished, checks data,
* and cleans up.
*
* @param	None
*
* @return	- XST_SUCCESS if DMA transfer is successful and data is correct,
*		- XST_FAILURE if fails.
*
* @note		None.
*
******************************************************************************/
int CheckDmaResult(XAxiDma * AxiDmaInstPtr)
{
	XAxiDma_BdRing *TxRingPtr;
	XAxiDma_BdRing *RxRingPtr;
	XAxiDma_Bd *BdPtr;
	int ProcessedBdCount;
	int FreeBdCount;
	int Status;

	TxRingPtr = XAxiDma_GetTxRing(AxiDmaInstPtr);
	RxRingPtr = XAxiDma_GetRxRing(AxiDmaInstPtr);
	printk("/******************* CheckDmaResult start ********************/\n");
	printk("/*************************** Tx HW ***************************/\n");

	int j = 0;
	printk("\n/******************************1*******************************/\n\n");
	while(4*j < 64){
		printk("TxBdring + %02x : %08x\n",(u32)(4*j) , *(u32 *)((u32)TxRingPtr->HwHead + 4*j));
	 	j++;
	 }
	printk("\n/*************************************************************/\n\n");
	j = 0;
	while(4*j < 64){
		printk("RxBdring + %02x : %08x\n",(u32)(4*j) , *(u32 *)((u32)RxRingPtr->HwHead + 4*j));
	 	j++;
	 }

	/* Wait until the one BD TX transaction is done */
	while (((int)(ProcessedBdCount = XAxiDma_BdRingFromHw(TxRingPtr, XAXIDMA_ALL_BDS, &BdPtr))) == 0) 
	{
		// printk("last check 1\n");
	}
	
	printk("\n/*******************************2******************************/\n\n");
	j = 0;
	while(4*j < 64){
		printk("TxBdring + %02x : %08x\n",(u32)(4*j) , *(u32 *)((u32)TxRingPtr->HwHead + 4*j));
	 	j++;
	 }
	printk("\n/*************************************************************/\n\n");
	j = 0;
	while(4*j < 64){
		printk("RxBdring + %02x : %08x\n",(u32)(4*j) , *(u32 *)((u32)RxRingPtr->HwHead + 4*j));
	 	j++;
	 }
	/* Free all processed TX BDs for future transmission */
	Status = XAxiDma_BdRingFree(TxRingPtr, ProcessedBdCount, BdPtr);
	if (Status != XST_SUCCESS) {
		printk("Failed to free %d tx BDs %d\r\n",
		    ProcessedBdCount, Status);
		return XST_FAILURE;
	}
	printk("\n/*********************************3****************************/\n\n");
	j = 0;
	while(4*j < 64){
		printk("TxBdring + %02x : %08x\n",(u32)(4*j) , *(u32 *)((u32)TxRingPtr->HwHead + 4*j));
	 	j++;
	 }
	printk("\n/*************************************************************/\n\n");
	j = 0;
	while(4*j < 64){
		printk("RxBdring + %02x : %08x\n",(u32)(4*j) , *(u32 *)((u32)RxRingPtr->HwHead + 4*j));
	 	j++;
	 }
	printk("/*************************** Rx HW ***************************/\n");
	/* Wait until the data has been received by the Rx channel */
	// udelay(1000);
	while (((int)(ProcessedBdCount = XAxiDma_BdRingFromHw(RxRingPtr, XAXIDMA_ALL_BDS, &BdPtr))) == 0) {
	}
	
	printk("last check 3\n");
	/* Check received data */
	if (CheckData() != XST_SUCCESS) {

		return XST_FAILURE;
	}
	printk("last check 4\n");
	/* Free all processed RX BDs for future transmission */
	Status = XAxiDma_BdRingFree(RxRingPtr, ProcessedBdCount, BdPtr);
	if (Status != XST_SUCCESS) {
		printk("Failed to free %d rx BDs %d\r\n",
		    ProcessedBdCount, Status);
		return XST_FAILURE;
	}

	/* Return processed BDs to RX channel so we are ready to receive new
	 * packets:
	 *    - Allocate all free RX BDs
	 *    - Pass the BDs to RX channel
	 */
	FreeBdCount = XAxiDma_BdRingGetFreeCnt(RxRingPtr);
	Status = XAxiDma_BdRingAlloc(RxRingPtr, FreeBdCount, &BdPtr);
	if (Status != XST_SUCCESS) {
		printk("bd alloc failed\r\n");
		return XST_FAILURE;
	}

	Status = XAxiDma_BdRingToHw(RxRingPtr, FreeBdCount, BdPtr);
	if (Status != XST_SUCCESS) {
		printk("Submit %d rx BDs failed %d\r\n", FreeBdCount, Status);
		return XST_FAILURE;
	}

	return XST_SUCCESS;
}